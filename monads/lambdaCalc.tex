\documentclass{beamer}
\usepackage{etex} % fixes new-dimension error
\usepackage{lmodern}
\input{macros/preamble}
\input{macros/macros}
\input{macros2}

%-------------- template --------------------------------------------------
\usetheme{metropolis}
\metroset{block=fill}
%\usetheme{Boadilla}

%----------------------------------------------------------------------------
\usepackage{graphicx,amsmath}
\usepackage{stmaryrd} % cf. interleave
\usepackage{booktabs}
\usepackage{amscd}
\usepackage{multicol}
\usepackage[absolute,overlay]{textpos}
\usepackage{alltt}
\usepackage{proof}
%------ using xy ------------------------------------------------------------
\usepackage[all]{xy}
%\def\larrow#1#2#3{\xymatrix{ #3 & #1 \ar[l] _-{#2} }}
\def\larrow#1#2#3{\xymatrix{ #3 & #1 \ar[l] _--{#2} }}
\def\rarrow#1#2#3{\xymatrix{ #1 \ar[r]^-{#2} & #3 }}
\def\arLaw#1#2#3#4#5{
\xymatrix{
        #1      \ar@/^1pc/[rr]^-{#4} &
        #5 &
        #2      \ar@/^1pc/[ll]^-{#3}
}}
\def\arLeq#1#2#3#4{\arLaw{#1}{#2}{#3}{#4}\leq}
%------ using pstricks (rnode etc) ------------------------------------------
\usepackage{pstricks,pst-node,pst-text,pst-3d}
%------ using color ---------------------------------------------------------

\newrgbcolor{goldenrod}{.80392 .60784 .11373}
\newrgbcolor{darkgoldenrod}{.5451 .39608 .03137}
\newrgbcolor{brown}{.15 .15 .15}
\newrgbcolor{darkolivegreen}{.33333 .41961 .18431}
%
%
\def\gold#1{{\goldenrod #1}}
% \def\dgold#1{{\darkgoldenrod #1}}
\def\dgold#1{{\alert{#1}}}
%\def\brw#1{{\brown #1}}
\def\dkb#1{{\blue #1}}
\def\tdkb#1{\textbf{\darkblue #1}}
%%\def\gre#1{{\green #1}}
\def\gre#1{{\darkolivegreen #1}}
\def\gry#1{{\gray #1}}
\def\rdb#1{{\red #1}}
\def\st{\mathbf{.}\,}
\def\laplace#1#2{*\txt{\mbox{ \fcolorbox{black}{myGray}{$\begin{array}{c}\mbox{#1}\\\\#2\\\\\end{array}$} }}}
%\newcommand{\galois}[2]{#1\; \dashv\; #2}

\def\eqm{\mathbin{\equiv}}                     
\def\noeqm{\mathbin{\not\!\equiv}}  
%\newcommand{\flam}[2]{\lambda_{#1}\; .\; #2}
\def\existential#1#2{\exists_{#1}\;.\; #2}
\def\existencial#1#2{\exists_{#1}\;.\; #2}

\def\pv#1#2{\langle #1 \rangle #2}
\def\nc#1#2{[#1]#2}
\def\pvo#1#2{\langle \! \! \! \langle #1 \rangle \! \! \! \rangle\, #2}
\def\nco#1#2{\llbracket #1 \rrbracket #2}
\def\cvg#1{\llbracket \downarrow \rrbracket #1}
\def\cvgr#1#2{\llbracket #1 \downarrow \rrbracket #2}
\def\cvgl#1#2{\llbracket \downarrow  #1 \rrbracket #2}
\def\cvglr#1#2{\llbracket \downarrow  #1 \downarrow \rrbracket #2}
\def\lfp#1#2{\mu {#1}\, .\, {#2}}
\def\lpf#1#2{\mu {#1}\, .\, {#2}}
\def\gfp#1#2{\nu {#1}\, .\, {#2}}
\def\gpf#1#2{\nu {#1}\, .\, {#2}}
\def\mset#1{\vvv #1 \vvv}
\def\vvv{\vert \! \vert}
\def\mnc#1{\vvv [#1] \vvv}
\def\mpv#1{\vvv \langle #1 \rangle \vvv}
\def\bcomp#1{#1^{\text{c}}}
\def\eqm{\mathbin{\simeq}}
\def\noeqm{\mathbin{\not\!\simeq}}
\def\universal#1#2{\forall_{#1}\;.\; #2}
\def\existential#1#2{\exists_{#1}\;.\; #2}
\def\oexistential#1#2{\exists^{1}_{#1}\;.\; #2}
\def\MM{\mathcal{M}}
\def\uppaal{\textsc{Uppaal}}
\def\cc#1{\mathcal{C}(#1)}
\def\R{\mathcal{R}}
\def\TL#1{\mathcal{T}(#1)}
\def\HL#1{\mathcal{H}(#1)}
\def\ET#1{\mathsf{ExecTime(#1)}}
\newcommand\mdoubleplus{\mathbin{+\mkern-10mu+}}

\AtBeginSection[]
{
    \begin{frame}
        \frametitle{Table of Contents}
        \tableofcontents[currentsection]
    \end{frame}
}

% context
\AtBeginSection[]
{
    \begin{frame}
        \frametitle{Table of Contents}
        \tableofcontents[currentsection]
    \end{frame}
}
\author[Renato Neves]{Renato Neves}

% logos of institutions
\titlegraphic{
  \begin{textblock*}{5cm}(6.7cm,7.57cm)
     \includegraphics[scale=0.05525]{./images/uminho.png}
  \end{textblock*}
  \begin{textblock*}{5cm}(9.4cm,7.57cm)
    \includegraphics[scale=0.50]{./images/haslab.pdf}
  \end{textblock*}
}

% No date
\date{}


\begin{document}

\title{Simply-typed $\lambda$-calculus: a brief overview}

\frame[plain]{\titlepage}


\begin{slide}{The Four Chapters of this course}
  Design and analysis of \alert{communicating} systems  

  Extension to the \alert{real-time} setting

  Going full \alert{cyber-physical}

  Programming with \alert{algebraic effects} \dots
  \caixa{
          \begin{center}
                a \alert{uniform} approach 
                to the previous chapters
          \end{center}
  }
\end{slide}

\begin{slide}{Overview}
        Modern programming typically involves different \alert{effects}
  \begin{itemize}
  \item (internal) state manipulation
  \item \alert{communication}
  \item probabilistic operations
  \item \alert{cyber-physical} behaviour
  \end{itemize}

  \vfill
  We will study the \alert{mathematical} foundations of 
  \caixa{
    \begin{center}
      Programming with effects
    \end{center}
  }
\end{slide}

\begin{slide}{Deductive reasoning}
  \begin{block}{Deductive reasoning}
          Assumptions + rules =  new knowledge
  \end{block}

  \begin{block}{Example}
        If $P$ implies $Q$ and $Q$ implies $R$ then $P$ implies $R$
  \end{block}

  Deductive reasoning has been studied since Aristotle \dots long before the
  age of artificial computers 

  So what does it have to do with programming?
\end{slide}

\begin{slide}{A basic deductive system pt. I}
  \begin{minipage}[0.3\textheight]{\textwidth}
  \begin{columns}[c]
  \begin{column}{0.5\textwidth}
          Let $\typeA,\typeB \dots$denote \alert{propositions} 
          (a property or a statement) and
          $\typeOne$ denote a proposition that always holds. If
          $\typeA$ and $\typeB$ are propositions then
  \end{column}
  \begin{column}{0.45\textwidth}
        \includegraphics[scale=0.2]{images/gentzen.jpg}
        \includegraphics[scale=0.16]{images/prawitz.jpg}
  \end{column}
  \end{columns}
  \end{minipage}

  \vspace{0.2cm}
  \begin{itemize}
    \item $\typeA \times \typeB$ is a proposition -- it denotes the
        conjunction of $\typeA$ and $\typeB$
    \item $\typeA \to \typeB$ is a proposition -- it tells that $\typeA$
        implies $\typeB$
  \end{itemize}
\end{slide}
\begin{slide}{A basic deductive system pt. II}
  
  $\Gamma$ denotes a list of propositions.  $\Gamma \vljud \typeA$ means ``if
  the propositions in $\Gamma$ hold then (we \alert{deduce} that) $\typeA$ also
  holds'' 

  \small{
  \begin{flalign*}
      \infer[(\rulename{ass})]{\Gamma \vljud \typeA}{\typeA \in \Gamma} \hspace{0.8cm}
      \infer[(\rulename{trv})]{\Gamma \vljud  1}{}  \hspace{0.8cm}
      \infer[(\rulename{\pi_1})]{\Gamma \vljud \typeA}{\Gamma \vljud \typeA \times \typeB} \hspace{0.8cm}
      \infer[(\rulename{\pi_2})]{\Gamma \vljud \typeB}{\Gamma \vljud \typeA \times \typeB}
  \end{flalign*}
  \begin{flalign*}
      \infer[(\rulename{prd})]{\Gamma \vljud \typeA \times \typeB}
      {\Gamma \vljud \typeA \qquad \Gamma \vljud \typeB} \hspace{0.4cm}
      \infer[(\rulename{cry})]{\Gamma \vljud \typeA \to \typeB}{\Gamma, \typeA \vljud  \typeB}
      \hspace{0.4cm}
      \infer[(\rulename{app})]{\Gamma \vljud \typeB}
      {\Gamma \vljud  \typeA \to \typeB \quad
        \Gamma \vljud  \typeA}
  \end{flalign*}
        } 
  \begin{block}{Exercise}
        Show that $\typeA \times \typeB \vdash \typeB \times \typeA$
  \end{block}
 
 \end{slide}
\begin{slide}{Building new rules from the original ones}
  The following rules are derivable from the previous system

  \begin{flalign*}
      \infer[]{\Gamma,\typeB \vljud \typeA}{\Gamma \vljud \typeA} \hspace{2cm}
      \infer[]{\Gamma, \typeB, \typeA,\Delta \vljud \typeC}{
      \Gamma, \typeA, \typeB,\Delta \vljud \typeC}
  \end{flalign*}
  \vfill
  \begin{block}{Exercise}
  Prove that $\typeA \to \typeB,\typeB \to \typeC \vljud \typeA \to \typeC$ 
  and also that $\typeA \to \typeB,\typeA \to \typeC \vljud \typeA \to \typeB 
  \times \typeC$. Are these deductions familiar?
  \end{block}
  \vfill
  Going back to programming \dots
\end{slide}
\begin{slide}{The essentials of programming}
  In order to study effectful programming, we should think of
  what are the \alert{basic features} of (higher-order) programming \dots
  \begin{itemize}
  \item variables  
  \item function application and abstraction
  \item pairing \dots
  \end{itemize}
  and base our study on the \alert{simplest programming language} containing
  these features \dots
  \caixa{
    \begin{center}
        Simply-typed $\lambda$-calculus
    \end{center}
  }
  \vfill
  The basis of \alert{\texttt{Haskell}}, \texttt{ML},
  \texttt{Eff}, \texttt{F\#}, \texttt{Agda}, \texttt{Elm} and many
  other programming languages
\end{slide}

\begin{frame}{Simply-typed $\lambda$-Calculus}
  \vspace{0.5cm}
  Types $\typeA \ni \typeOne \mid 
  \typeA \times \typeA \mid \typeA \to \typeA$

  $\Gamma$ is now a \alert{non-repetitive} list of typed variables
    $x_1 : \typeA_1 \dots x_n : \typeA_n$

  Programs are built according to the previous \alert{deduction rules}

  \begin{flalign*}
      \infer[(\rulename{ass})]{\Gamma \vljud x : \typeA}{x :
        \typeA \in \Gamma} \hspace{1.2cm}
      \infer[(\rulename{triv})]{\Gamma \vljud \ast : 1}{}  \hspace{1.2cm}
      \infer[(\rulename{\pi_1})]{\Gamma \vljud \pi_1 V : \typeA }
      {\Gamma \vljud V: \typeA \times \typeB}
  \end{flalign*}
  \begin{flalign*}
     \infer[(\rulename{prd})]{\Gamma \vljud \langle V,U \rangle :
        \typeA \times \typeB}
      {\Gamma \vljud V: \typeA \qquad \Gamma \vljud U: \typeB} \hspace{1cm}
      \infer[(\rulename{cry})]{\Gamma \vljud \lambda x : \typeA . \, V : \typeA
        \to \typeB}
      {\Gamma, x : \typeA \vljud V : \typeB}
    \end{flalign*}
   \begin{flalign*}
      \infer[(\rulename{app})]{\Gamma \vljud V \, U : \typeB}
      {\Gamma \vljud  V : \typeA \to \typeB \quad
        \Gamma \vljud  U : \typeA}
    \end{flalign*}
\end{frame}

\begin{slide}{Examples of $\lambda$-terms}
  $x : \typeA \vljud x : \typeA$ (identity)
  
  \vspace{0.5cm}
  $x : \typeA \vljud \langle x, x \rangle : \typeA \times \typeA$
  (duplication)

  \vspace{0.5cm}
  $x : \alert{\typeA \times \typeB}
  \vljud \langle \pi_2\ x , \pi_1\ x \rangle : \alert{ \typeB \times \typeA }$ (swap)

  \vspace{0.5cm}
  $f : \alert{\typeA \to \typeB}, g : \alert{\typeB \to \typeC} \vljud
  \lambda x : \typeA . \> g (f \> x) : \alert{\typeA \to \typeC}$ (composition)

  \vfill
  \begin{block}{Exercise}
    Build a $\lambda$-term
    $f : \typeA \to \typeB, g : \typeA \to \typeC \vljud\ ? : \typeA 
    \to \typeB \times \typeC$ that pairs the outputs given by $f$
    and $g$
  \end{block}
\end{slide}

\begin{slide}{Semantics for simply-typed $\lambda$-calculus}
  We wish to assign a \alert{mathematical meaning} to $\lambda$-terms
  \begin{flalign*}
    \sem{-} : \lambda\text{-terms} \longrightarrow ...
  \end{flalign*}
  so that we can reason about them in a rigorous way, and take advantage
  of known mathematical theories
  \vfill \pause
  
  This is the goal of the next slides: we will study how to interpret
  $\lambda$-terms as \alert{functions}. But first \dots
\end{slide}

\begin{slide}{Basic facts about functions}

  For every set $X$, there is a `trivial' function
  \begin{flalign*}
    ! : X \longrightarrow \{ \star \} = 1, \hspace{1cm} \alert{! \, (x) = \star}
  \end{flalign*}
  \vfill
  We can always pair two functions
  $f : X \to A$, $g : X \to B$ into
  \begin{flalign*}
    \pv{f,g} : X \to A \times B, \hspace{1cm} \alert{\pv{f,g}(x) = (f \> x, g \> x)}
  \end{flalign*}
  \vfill
  Consider two sets $X,Y$. There exist `projection' functions
  \begin{flalign*}
    \pi_1 : X \times Y \to X,  \hspace{1cm} \alert{\pi_1(x,y) = x} \\
    \pi_2 : X \times Y \to Y,  \hspace{1cm} \alert{\pi_2(x,y) = y}
  \end{flalign*}
\end{slide}

\begin{slide}{Basic facts about functions}
  We can always `curry' a function $f : X \times Y \to Z$ into
  \begin{flalign*}
    \lambda f : X \to Z^Y, \hspace{1cm} \alert{\lambda f (x) = (y \mapsto f(x,y))}
  \end{flalign*}
  \vfill
  Consider sets $X,Y, Z$. There exists an `application' function
  \begin{flalign*}
    \mathrm{app} : Z^Y  \times Y \to Z, \hspace{1cm}
    \alert{\mathrm{app}(f,y) = f \> y}
  \end{flalign*}
\end{slide}

\begin{slide}{Functional semantics for the simply-typed $\lambda$-calculus}
  Types $\typeA$ are interpreted as \alert{sets} $\sem{\typeA}$
  \begin{flalign*}
    \sem{1} & = \{ \star \} \\
    \sem{\typeA \times \typeB} & = \sem{\typeA} \times \sem{\typeB} \\
   \sem{\typeA \to \typeB} & = \sem{\typeB}^{\sem{\typeA}} 
 \end{flalign*}
 \vfill
 A typing context $\Gamma$ is interpreted as
 \begin{flalign*}
  \sem{\Gamma}\ = \sem{x_1 : \typeA_1 \times \dots \times x_n : \typeA_n}\ =
 \sem{\typeA_1} \times \dots \times \sem{\typeA_n} 
 \end{flalign*}
 \vfill
 A $\lambda$-term $\Gamma \vljud V : \typeA$ is interpreted as a \alert{function}
 \begin{flalign*}
   \sem{\Gamma \vljud V : \typeA}\ : \sem{\Gamma}\ \longrightarrow \sem{\typeA}
 \end{flalign*}
\end{slide}

\begin{slide}{Functional semantics for the simply-typed $\lambda$-calculus}
  A $\lambda$-term $\Gamma \vljud V : \typeA$ is interpreted as a
  function
 \begin{flalign*}
   \sem{\Gamma \vljud V : \typeA}\ : \sem{\Gamma}\ \longrightarrow \sem{\typeA}
 \end{flalign*}
 in the following way
 \small{
   \begin{flalign*}
      \infer[]{\sem{\Gamma \vljud x_i : \typeA} = \pi_i}{x_i :
        \typeA \in \Gamma} \hspace{1.2cm}
      \infer[]{\sem{\Gamma \vljud \ast : 1}\ =\ !}{}  \hspace{1.2cm}
      \infer[]{\sem{\Gamma \vljud \pi_1 V : \typeA} = \pi_1 \comp f }
      {\sem{\Gamma \vljud V: \typeA \times \typeB} = f}
  \end{flalign*}
  \begin{flalign*}
      \infer[]{\sem{\Gamma \vljud \langle V,U \rangle :
        \typeA \times \typeB}\ = \pv{f,g}}
    {\sem{\Gamma \vljud V: \typeA}\ = f \qquad \sem{\Gamma \vljud U: \typeB}\ = g}
    \hspace{0.3cm}
     \infer[]{\sem{\Gamma \vljud \lambda x : \typeA . \, V : \typeA
        \to \typeB}\ = \lambda f}
      {\sem{\Gamma, x : \typeA \vljud V : \typeB}\ = f}
    \end{flalign*}
   \begin{flalign*}
      \infer[]{\sem{\Gamma \vljud V \, U : \typeB}\ = \mathrm{app} \comp \pv{f,g}}
      {\sem{\Gamma \vljud  V : \typeA \to \typeB}\ = f \quad
        \sem{\Gamma \vljud  U : \typeA}\ = g}
    \end{flalign*}
}
\end{slide}

\begin{slide}{Exercises}
  Show that the following equations hold.

  \begin{flalign*}
    \sem{x : \typeA, y : \typeB  \vljud \pi_1 \pv{x,y} : \typeA}\ & =\
    \sem{x : \typeA, y : \typeB  \vljud x : \typeA} \\
    \sem{\Gamma  \vljud V: \typeA}\ & =\
    \sem{\Gamma  \vljud \langle \pi_1 V, \pi_2 V \rangle : \typeA}
    \\
    \sem{ x : \typeA \vljud (\lambda y. \, \pv{x,y})\>  x : \typeA \times \typeA }\,
                                    & =\
                                    \sem{ x : \typeA \vljud \pv{x,x} : \typeA \times \typeA }
  \end{flalign*}
\end{slide}

\end{document}
