\documentclass{beamer}
\usepackage{etex} % fixes new-dimension error
\usepackage{lmodern}
\input{macros/preamble}
\input{macros/macros}
\input{macros2}

%-------------- template --------------------------------------------------
\usetheme{metropolis}
\metroset{block=fill}
%\usetheme{Boadilla}

%----------------------------------------------------------------------------
\usepackage{graphicx,amsmath}
\usepackage{stmaryrd} % cf. interleave
\usepackage{booktabs}
\usepackage{amscd}
\usepackage{multicol}
\usepackage[absolute,overlay]{textpos}
\usepackage{alltt}
\usepackage{proof}
%------ using xy ------------------------------------------------------------
\usepackage[all]{xy}
%\def\larrow#1#2#3{\xymatrix{ #3 & #1 \ar[l] _-{#2} }}
\def\larrow#1#2#3{\xymatrix{ #3 & #1 \ar[l] _--{#2} }}
\def\rarrow#1#2#3{\xymatrix{ #1 \ar[r]^-{#2} & #3 }}
\def\arLaw#1#2#3#4#5{
\xymatrix{
        #1      \ar@/^1pc/[rr]^-{#4} &
        #5 &
        #2      \ar@/^1pc/[ll]^-{#3}
}}
\def\arLeq#1#2#3#4{\arLaw{#1}{#2}{#3}{#4}\leq}
%------ using pstricks (rnode etc) ------------------------------------------
\usepackage{pstricks,pst-node,pst-text,pst-3d}
%------ using color ---------------------------------------------------------

\newrgbcolor{goldenrod}{.80392 .60784 .11373}
\newrgbcolor{darkgoldenrod}{.5451 .39608 .03137}
\newrgbcolor{brown}{.15 .15 .15}
\newrgbcolor{darkolivegreen}{.33333 .41961 .18431}
%
%
\def\gold#1{{\goldenrod #1}}
% \def\dgold#1{{\darkgoldenrod #1}}
\def\dgold#1{{\alert{#1}}}
%\def\brw#1{{\brown #1}}
\def\tdkb#1{\textbf{\darkblue #1}}
%%\def\gre#1{{\green #1}}
\def\gre#1{{\darkolivegreen #1}}
\def\gry#1{{\gray #1}}
\def\rdb#1{{\red #1}}
\def\st{\mathbf{.}\,}
\def\laplace#1#2{*\txt{\mbox{ \fcolorbox{black}{myGray}{$\begin{array}{c}\mbox{#1}\\\\#2\\\\\end{array}$} }}}
%\newcommand{\galois}[2]{#1\; \dashv\; #2}

\def\eqm{\mathbin{\equiv}}                     
\def\noeqm{\mathbin{\not\!\equiv}}  
%\newcommand{\flam}[2]{\lambda_{#1}\; .\; #2}
\def\existential#1#2{\exists_{#1}\;.\; #2}
\def\existencial#1#2{\exists_{#1}\;.\; #2}

\def\pv#1#2{\langle #1 \rangle #2}
\def\nc#1#2{[#1]#2}
\def\pvo#1#2{\langle \! \! \! \langle #1 \rangle \! \! \! \rangle\, #2}
\def\nco#1#2{\llbracket #1 \rrbracket #2}
\def\cvg#1{\llbracket \downarrow \rrbracket #1}
\def\cvgr#1#2{\llbracket #1 \downarrow \rrbracket #2}
\def\cvgl#1#2{\llbracket \downarrow  #1 \rrbracket #2}
\def\cvglr#1#2{\llbracket \downarrow  #1 \downarrow \rrbracket #2}
\def\lfp#1#2{\mu {#1}\, .\, {#2}}
\def\lpf#1#2{\mu {#1}\, .\, {#2}}
\def\gfp#1#2{\nu {#1}\, .\, {#2}}
\def\gpf#1#2{\nu {#1}\, .\, {#2}}
\def\mset#1{\vvv #1 \vvv}
\def\vvv{\vert \! \vert}
\def\mnc#1{\vvv [#1] \vvv}
\def\mpv#1{\vvv \langle #1 \rangle \vvv}
\def\bcomp#1{#1^{\text{c}}}
\def\eqm{\mathbin{\simeq}}
\def\noeqm{\mathbin{\not\!\simeq}}
\def\universal#1#2{\forall_{#1}\;.\; #2}
\def\existential#1#2{\exists_{#1}\;.\; #2}
\def\oexistential#1#2{\exists^{1}_{#1}\;.\; #2}
\def\MM{\mathcal{M}}
\def\uppaal{\textsc{Uppaal}}
\def\cc#1{\mathcal{C}(#1)}
\def\R{\mathcal{R}}
\def\TL#1{\mathcal{T}(#1)}
\def\HL#1{\mathcal{H}(#1)}
\def\ET#1{\mathsf{ExecTime(#1)}}
\newcommand\mdoubleplus{\mathbin{+\mkern-10mu+}}

\AtBeginSection[]
{
    \begin{frame}
        \frametitle{Table of Contents}
        \tableofcontents[currentsection]
    \end{frame}
}

\author{Renato Neves}

% logos of institutions
\titlegraphic{
  \begin{textblock*}{5cm}(6.7cm,7.57cm)
     \includegraphics[scale=0.05525]{./images/uminho.png}
  \end{textblock*}
  \begin{textblock*}{5cm}(9.4cm,7.57cm)
    \includegraphics[scale=0.50]{./images/haslab.pdf}
  \end{textblock*}
}

% No date
\date{}

\begin{document}

\title{Algebraic operations and $\lambda$-calculus}

\frame[plain]{\titlepage}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Background}
\begin{slide}{Recalling $\lambda$-Calculus}
  \[
  \typeA \ni \typeOne \mid 
  \typeA \times \typeA \mid \typeA \to \typeA
  \]

  \begin{flalign*}
      \infer[]{\Gamma \vljud x : \typeA}{x :
        \typeA \in \Gamma} \hspace{1.2cm}
      \infer[]{\Gamma \vljud \ast : 1}{}  \hspace{1.2cm}
      \infer[]{\Gamma \vljud \pi_1 V : \typeA }
      {\Gamma \vljud V: \typeA \times \typeB}
  \end{flalign*}
  \begin{flalign*}
      \infer[]{\Gamma \vljud \langle V,U \rangle :
        \typeA \times \typeB}
      {\Gamma \vljud V: \typeA \qquad \Gamma \vljud U: \typeB} \hspace{1cm}
     \infer[]{\Gamma \vljud \lambda x : \typeA . \, V : \typeA
        \to \typeB}
      {\Gamma, x : \typeA \vljud V : \typeB}
    \end{flalign*}
   \begin{flalign*}
      \infer[]{\Gamma \vljud V \, U : \typeB}
      {\Gamma \vljud  V : \typeA \to \typeB \quad
        \Gamma \vljud  U : \typeA}
    \end{flalign*}

\end{slide}
\begin{slide}{Sequential Composition}
  A ``new'' deductive rule
  \begin{flalign*}
    \infer{\Gamma \vljud x \leftarrow V; U : \typeB}{
      \Gamma \vljud V : \typeA \qquad x : \typeA \vljud U : \typeB}
  \end{flalign*}
  It reads as ``bind the computation $V$ to $x$ and then run $U$''

  \vspace{0.5cm}
  Interpretation defined as
  \begin{flalign*}
    \infer{\sem{\Gamma \vljud x \leftarrow V; U : \typeB}\ = g \comp f}{
      \sem{\Gamma \vljud V : \typeA}\ = f \qquad
      \sem{x : \typeA \vljud U : \typeB}\ = g}
  \end{flalign*}

\end{slide}
\section{Integration of algebraic operations in $\lambda$-calculus}
\begin{slide}{Signatures}
  \begin{block}{Signature}
  A set  
  $\Sigma = \{ (\sigma_1,n_1), (\sigma_2,n_2), \dots \}$ 
  of operations $\sigma_i$ paired with the \alert{number}
  of inputs $n_i$ they are supposed to receive
  \end{block}
  
  Signatures will later be integrated in
  $\lambda$-calculus

  They constitute the aforementioned \alert{algebraic operations}

  \vfill
  \begin{block}{Examples}
    \begin{itemize}
    \item Exceptions: $\{ (\mathrm{e},0) \}$
    \item Read a bit from the environment: $\{ (\mathrm{read},2) \}$
    \item Wait calls: $\{ (\mathrm{wait}_n, 1) \mid n \in \mathbb{N} \}$
    \item Non-deterministic choice: $\{ (\mathrm{+},2) \}$
    \end{itemize}
  \end{block}
\end{slide}


\begin{slide}{Algebraic operations in $\lambda$-calculus}
  We choose a signature $\Sigma$ of algebraic operations
  and introduce a new deductive rule

  \begin{flalign*}    
      \infer[]{\Gamma \vljud \sigma(M_1,\dots,M_n) : \typeA}
      {(\sigma,n) \in \Sigma \qquad \forall i \leq n. \> \Gamma \vljud M_i : \typeA}
    \end{flalign*}
\end{slide}

\begin{slide}{Examples of effectful $\lambda$-terms}
  \begin{itemize}
          \item $x : \typeA \vljud
                  \mathrm{wait}_1(x) : \typeA $ -- adds \alert{delay} of one second 
                to returning $x$
          \item $\Gamma \vljud \mathrm{e}() : \typeA$ -- raises an 
                \alert{exception} $e$
          \item $\Gamma \vljud \mathrm{write}_v(M) : \typeA$ -- writes 
                $v$ in \alert{memory} and then runs $M$
          \item $x : \typeA \times \typeA \vljud \mathrm{read}(\pi_1 \> x, 
                \pi_2 \> x) : \typeA$ -- \alert{receives} a bit: 
                if  the bit is $0$ it returns $\pi_1 \> x$ otherwise it 
                returns $\pi_2 \> x$
  \end{itemize}
  
  \pause
  \vfill
  \begin{block}{Exercise}
    Define a $\lambda$-term $x : \typeA \vljud\ ? : \typeA$ that
    requests a bit from the user and depending on the value read it
    returns $x$ with either one or two seconds of delay.
  \end{block}
\end{slide}

\section{Semantics of $\lambda$-calculus with algebraic operations}


\begin{slide}{Semantics of $\lambda$-Calculus with algebraic Operations}

  How to provide semantics to these programming languages?

  Short answer: via \alert{\underline{monads}}

  Long answer: see the next slides \dots

\end{slide}

\begin{slide}{The core idea}
  Programs $\Gamma \vljud V  : \typeA$ interpreted
  as functions
  \begin{flalign*}
    \sem{\Gamma \vljud V : \typeA}\ : \sem{\Gamma} \longrightarrow \sem{\typeA}
  \end{flalign*}

  \dots\ and there exists \alert{only one} function of type
  \begin{flalign*}
   \sem{\Gamma} \longrightarrow \alert{\sem{1}} 
  \end{flalign*}

  Problem: it is then necessarily the case that
  \begin{flalign*}
    \sem{\Gamma \vljud x : \typeOne}\ = \sem{\Gamma \vljud
      \mathrm{wait_1}(x) : \typeOne}
  \end{flalign*}
  despite these programs having different execution times
\end{slide}


\begin{slide}{The core idea pt. II}
  Interpreted a program $\Gamma \vljud V : \typeA$ as a function
 \begin{flalign*}
   \sem{\Gamma \vljud V : \typeA}\ : \sem{\Gamma}\ \longrightarrow \sem{\typeA}
 \end{flalign*}
 which returns values in $\sem{\typeA}$. \alert{But values now come with
 effects \dots}

 Instead of having $\sem{\typeA}$ as set of outputs, we will have
 a set $T\sem{\typeA}$ of \alert{effectful values} 
 \begin{flalign*}
   \sem{\Gamma \vljud M : \typeA}\ : \sem{\Gamma}\ \longrightarrow T\sem{\typeA}
 \end{flalign*}

 $T$ should thus be a \alert{set-constructor}: given a set of outputs $X$ it
 returns a set of effectful values $T X$ over $X$
\end{slide}

\begin{slide}{The core idea pt. III}
  For wait calls, the corresponding set-constructor $T$ is defined as
  \begin{flalign*}
    X \mapsto \mathbb{N} \times X
  \end{flalign*}
  \ie\ values in $X$ paired with an \alert{execution time}
  \vfill
  For exceptions, the corresponding set-constructor $T$ is defined as
  \begin{flalign*}
    X \mapsto X + \{ e \}
  \end{flalign*}
  \ie\ values in $X$ plus an element $e$ \alert{representing the exception}
\end{slide}

\begin{slide}{Another problem}
  This idea of a set-constructor $T$ seems good, but it breaks 
  sequential composition
  \begin{flalign*}
    \sem{\Gamma \vljud M : \typeA}\ &: \sem{\Gamma} \to \alert{T\sem{\typeA}} \\
    \sem{x : \typeA \vljud N : \typeB}\ & : \alert{\sem{\typeA}} \to T\sem{\typeB}
  \end{flalign*}
    
  We need a way to convert a function $h : X \to TY$ into a function
  of the type
  \begin{flalign*}
    h^\star : TX \to TY
  \end{flalign*}
\end{slide}

\begin{slide}{Another problem pt. II}

  There are set-constructors $T$ for which this is possible

  \vspace{0.5cm}
  In the case of \alert{wait-calls}
  \begin{flalign*}
    \infer{f^\star(n,x) = (n+m,y) \text{ where } f(x) = (m,y)}
    {f : X \to TY = \mathbb{N} \times Y}
  \end{flalign*}

  \vspace{0.5cm}
  In the case of \alert{exceptions}
  \begin{flalign*}
      \infer{f^\star(x) = f (y) \qquad f^\star(e) = e}{f : X \to TY = Y + \{e\}}
  \end{flalign*}
\end{slide}

\begin{slide}{Testing the idea\dots}
  \begin{flalign*}
   & \, \sem{x : \typeOne \vljud y \leftarrow \mathrm{wait_1}(x) ;
   \mathrm{wait_2}(y) : \typeOne} \\[0.2cm]
   & =\  \sem{ y : \typeOne \vljud \mathrm{wait_2}(y) : \typeOne }^\ast\ \comp\
   \sem{x : \typeOne \vljud \mathrm{wait_1}(x) : \typeOne} \\[0.2cm]
   & =\ (v \mapsto (2,v))^\ast\ \comp\ (v \mapsto (1,v)) \\[0.2cm]
   & =\ v \mapsto (3,v)
  \end{flalign*}
\end{slide}

\begin{slide}{Yet another problem}

  Idea of interpreting $\lambda$-terms $\Gamma \vljud M : \typeA$ as functions
  \begin{flalign*}
   \sem{\Gamma \vljud M : \typeA}\ : \sem{\Gamma}\ \longrightarrow T\sem{\typeA}
  \end{flalign*}
  looks good but it presupposes that all terms invoke
  effects

  \vfill
  Some terms do not do this, \eg\
  \begin{flalign*}
    \sem{x: \typeA \vljud x : \typeA}\ : \sem{\typeA}\ \longrightarrow \sem{\typeA}
  \end{flalign*}

  \begin{block}{Solution}
   $T\sem{\typeA}$ should include \alert{effect-free} values, 
   and we should have 
   \begin{flalign*}
    \eta_{\sem{\typeA}} : \sem{\typeA}\ \longrightarrow T\sem{\typeA}
   \end{flalign*}
   which maps a value to its effect-free representation
  \end{block}  
\end{slide}

\begin{slide}{Yet another problem pt. II}

  Again there are set-constructors $T$ for which this is possible:

  \vspace{0.5cm}
  In the case of \alert{wait-calls}
  \begin{flalign*}
    \infer{\eta_X (x) = (0,x)}
    {TX = \mathbb{N} \times X}
  \end{flalign*}
  (\ie\ no wait call was invoked)
  
  \vspace{1cm}
  In the case of \alert{exceptions}
  \begin{flalign*}
      \infer{\eta_X (x) = x}{TX = X + \{e\}}
  \end{flalign*}
  (\ie\ the exception $e$ was never raised) 

\end{slide}

\begin{slide}{Monads unlocked!!}
  Our previous analysis \alert{naturally} leads to the
  notion of a \alert{monad}

  \vfill
  \begin{block}{Monad}
    A triple $(T,\eta,(-)^\star)$ where $T$ is a
    set-constructor, $\eta$ a function
    $\eta_X : X \to TX$ for each set $X$, and $(-)^\star$
    an operation
    \begin{flalign*}
      \infer{f^\star : TX \to TY}{f : X \to TY}
    \end{flalign*}
    s.t. the following laws hold:
    $\eta^{\star}=\id$, %&&
    $f^{\star}\comp \eta=f$, %&&
    $(f^{\star} \comp g)^{\star}=f^{\star} \comp g^{\star}$
  \end{block}

  \vfill
  These laws are required to forbid ``weird''
  computational behaviour
\end{slide}

\begin{slide}{Exercise}
  Show that the set-constructor
  \begin{flalign*}
    X \mapsto \mathbb{N} \times X
  \end{flalign*}
  can be equipped with a monadic structure
  \vfill
  
  Show that the set-constructor
  \begin{flalign*}
    X \mapsto X + 1
  \end{flalign*}
  can be equipped with a monadic structure
\end{slide}
%\section{Capitalising on the Lessons Learned Thus Far}
%\begin{frame}{To Keep In Mind}
%  Let us use what we learned thus far to extend $\lambda$-calculus
%  with algebraic operations and provide it with a proper semantics
%
%  \vspace{0.5cm}
%  To this effect, recall that,
%  \begin{itemize}
%  \item we fix a signature $\Sigma$ of algebraic operations
%  \item we have monads $(T,\eta,(-)^\star)$ at our disposal
%  \item Programs $\Gamma \vljud V : \typeA$ can be seen either as
%    functions of type $\sem{\Gamma} \to \sem{\typeA}$ or of 
%    type $\sem{\Gamma} \to T\sem{\typeA}$
%  \end{itemize}
%\end{frame}
%\begin{slide}{Semantics for Effectful Simply-Typed $\lambda$-Calculus}
%    Types $\typeA$ are interpreted as \alert{sets} $\sem{\typeA}$
%  \begin{flalign*}
%    \sem{1}\ = \{ \star \} \hspace{.7cm}
%    \sem{\typeA \times \typeB}\ = \sem{\typeA} \times \sem{\typeB} \hspace{0.7cm}
%   \sem{\typeA \to \typeB}\ = (T\sem{\typeB})^{\sem{\typeA}} 
% \end{flalign*}
% \vfill
% A typing context $\Gamma$ is interpreted as
% \begin{flalign*}
%  \sem{\Gamma}\ = \sem{x_1 : \typeA_1 \times \dots \times x_n : \typeA_n}\ =
% \sem{\typeA_1} \times \dots \times \sem{\typeA_n} 
% \end{flalign*}
% \vfill
% For each operation $(\sigma,n) \in \Sigma$ and set $X$ we postulate
% the existence of a map
% \begin{flalign*}
%   \sem{\sigma}_X : (TX)^n \longrightarrow TX
% \end{flalign*}
%\end{slide}
%
%
%\begin{slide}{Semantics for effectful simply-typed $\lambda$-calculus II}
%  \footnotesize
%   \begin{flalign*}
%    \infer{\sem{\Gamma \vljud x_i}\ = \pi_i}{x_i : \typeA \in \Gamma}
%    \hspace{1cm}
%    \infer{\sem{\Gamma \vljud \ast}\ = \> !}{}
%    \hspace{1cm}
%    \infer{\sem{\Gamma \vljud \langle V, U \rangle : \typeA \times \typeB}\ = \pv{f,g}}
%    {\sem{\Gamma \vljud V : \typeA} = f \qquad \sem{\Gamma \vljud U : \typeB}\ = g}
%  \end{flalign*}
%  \begin{flalign*}
%       \infer[]{\sem{\Gamma \vljud \lambda x : \typeA . \, M : \typeA
%        \to \typeB}\ = \lambda f}
%    {\sem{\Gamma, x : \typeA \cojud M : \typeB}\ = f} \hspace{2cm}
%          \infer[]{\sem{\Gamma \vljud \pi_1 V : \typeA}\ = \pi_1 \comp f }
%      {\sem{\Gamma \vljud V: \typeA \times \typeB}\ = f}
%  \end{flalign*}
%  \dotfill
%  \begin{flalign*}
%    \infer{\sem{\Gamma \cojud \ret V : \typeA}\ = \eta \comp f}
%    {\sem{\Gamma \vljud V : \typeA}\ = f} \hspace{1cm}
%    \infer{\sem{\Gamma \cojud x \leftarrow M \pcomp N : \typeB} = g^\star \comp f}
%    {\sem{\Gamma \cojud M : \typeA} = f \qquad \sem{x:\typeA \cojud N : \typeB} = g}
%  \end{flalign*}
%  \begin{flalign*}
%     \infer[]{\sem{\Gamma \cojud V \, U : \typeB}\ = \mathrm{app} \comp \pv{f,g}}
%     {\sem{\Gamma \vljud  V : \typeA \to \typeB}\ = f \quad
%     \sem{\Gamma \vljud  U : \typeA}\ = g} \\[2.5ex]
%     \infer{\sem{\Gamma \cojud \sigma(M_1, \dots M_n)}\ = \sem{\sigma}_{\sem{\typeA}}
%     \comp \pv{f_1,\dots,f_n}}{(\sigma, n) \in \Sigma \qquad \forall i
%     \leq n . \> \sem{\Gamma \cojud M_i : \typeA} = f_i}
%  \end{flalign*}
%\end{slide}
%
%\begin{slide}{Exercise}
%  Use the interpretation rules to prove that
%  the equations below hold
%  \fontsize{7.7}{10}\selectfont % \scriptsize  
%  \vspace{0.5cm}
%
%  \begin{flalign*}
%    & \sem{\Gamma \vljud x \leftarrow \ret \ast \pcomp (\ret x) : \typeOne}\
%    = \sem{\Gamma \vljud \ret \ast : \typeOne} \\ 
%    & \text{ (hint: one of the monad laws)} \\[2ex]
%    %
%    & \sem{\Gamma \vljud x \leftarrow \mathrm{wait_1}(\ret \ast) \pcomp (\ret x) :
%    \typeOne}\  =
%    \sem{\Gamma \vljud x \leftarrow \ret \ast \pcomp \mathrm{wait_1}(\ret x)
%    : \typeOne}\ \\
%    & \text{ (hint: two of the monad laws) } \\[2ex]
%    & \sem{\Gamma \vljud
%      x \leftarrow \mathrm{wait_1}(\ret \ast) \pcomp \mathrm{wait_1}(\ret x) : \typeOne}\
%    = \sem{\Gamma \vljud x \leftarrow \mathrm{wait_2}(\ret \ast) \pcomp (\ret x) : \typeOne}  \\
%    & \text{ }
%  \end{flalign*}
%\end{slide}
%
%
%\begin{slide}{Exercises}
%  Build a $\lambda$-term that receives a value, waits one second, and
%  returns the same value. Run this in \texttt{Haskell} using
%  \texttt{DurationMonad.hs}. What is the value obtained when you feed this
%  function with ``Hi''? Justify.
%
%  \vfill
%  Can you build a $\lambda$-term that receives a function
%  $f : \typeA \to \typeA$, receives a value $x : \typeA$, and applies
%  $f$ to $x$ twice? In \alert{classical} $\lambda$-calculus such would
%  be defined as
%  \begin{flalign*}
%    \lambda f : \typeA \to \typeA.\ \lambda x : \typeA. \> f (f \> x)
%  \end{flalign*}
%\end{slide}
%
%% \begin{slide}{Sharing contexts}
%%   It is very useful to have two programs $M,N$ in sequential composition
%%   $x \leftarrow M \pcomp N$ that are able share contexts
%
%%   \vfill
%%   In other words, it would be useful to have the following rule for
%%   sequential composition
%%   \begin{flalign*}
%%     \infer{\dkb{\Gamma} \cojud x \leftarrow M \pcomp N : \typeB}
%%     {\dkb{\Gamma} \cojud M : \typeA \qquad \dkb{\Gamma}, x:\typeA \cojud N : \typeB }
%%   \end{flalign*}
%
%%   \vfill
%%   \pause
%%   This would allow us to solve the previous exercise quite easily
%%   \begin{flalign*}
%%     \lambda f : \typeA \to \typeA, \lambda x : \typeA . \>
%%     y \leftarrow f(x) \pcomp f(y)
%%   \end{flalign*}
%% \end{slide}
%
%% \begin{slide}{Sharing contexts}
%%   The natural way of interpreting the rule would be
%%     \begin{flalign*}
%%     \infer{\sem{\Gamma \cojud x \leftarrow M \pcomp N : \typeB}\ =  g^\star  \comp \pv{\id,f}}
%%     {\sem{\Gamma \cojud M : \typeA}\ = f \qquad \sem{\Gamma, x:\typeA \cojud N : \typeB}\ = g }
%%   \end{flalign*}
%%   but $\pv{\id,f} : \sem{\Gamma}\ \longrightarrow \dkb{\sem{\Gamma} \times T\sem{\typeA}}$
%%   and $g^\star : \dkb{T(\sem{\Gamma} \times \sem{\typeA})} \longrightarrow T\sem{\typeB}$
%%   \vfill
%%   We need to find a suitable function
%%   \begin{flalign*}
%%     \mathrm{str}:
%%     \sem{\Gamma} \times T\sem{\typeA} \longrightarrow T(\sem{\Gamma} \times \sem{\typeA})
%%   \end{flalign*}
%%   \vfill \pause
%%   There is a natural way of doing this!
%% \end{slide}
%
%% \begin{slide}{Tensorial strength}
%%   For every monad $T$ and function $f : X \to Y$ we can build
%%   a function
%%   \begin{flalign*}
%%     \dkb{Tf = (\eta \comp f)^\star} : TX \to TY
%%   \end{flalign*}
%
%%   \vfill
%%   Note also that for every $x \in X$ we can define
%%   \begin{flalign*}
%%     \id_x : Y \to X \times Y, \quad \dkb{y \mapsto (x,y)}
%%   \end{flalign*}
%
%%   \vfill
%%   From these, we define the so-called \dkb{strength} of $T$
%%   \begin{flalign*}
%%     \mathrm{str} : X \times TY \to T(X \times Y), \quad
%%     \dkb{(x,t) \mapsto (T \id_x) (t)}
%%   \end{flalign*}
%%   \vfill
%%   Finally,
%%   \begin{flalign*}
%%     \infer{\sem{\Gamma \cojud x \leftarrow M \pcomp N : \typeB}\ =
%%       g^\star \comp \mathrm{str} \comp \pv{\id,f}} {\sem{\Gamma \cojud M : \typeA}\ = f
%%       \qquad \sem{\Gamma, x:\typeA \cojud N : \typeB}\ = g }
%%   \end{flalign*}
%% \end{slide}
%
%% \begin{slide}{Exercises}
%%   Given an explicit definition for the tensorial strength of
%%   \begin{itemize}
%%   \item the monad of exceptions,
%%   \item the monad of durations
%%   \end{itemize}
%
%%   \vfill
%%   Consider the $\lambda$-terms
%%   \begin{flalign*}
%%     \lambda f : \typeA \to \typeA, \lambda x : \typeA . \>
%%     y \leftarrow f(x) \pcomp f(y) \\
%%     g = \lambda x : \typeA . \> \mathrm{wait_1}(\ret \> x)
%%   \end{flalign*}
%%   What is the result of computing the $\lambda$-term below?
%%   \begin{flalign*}
%%    \Big (\lambda f : \typeA \to \typeA, \lambda x : \typeA . \>
%%     y \leftarrow f(x) \pcomp f(y) \Big ) \> g \> "Hi"
%%   \end{flalign*}
%
%% \end{slide}
%
%% \begin{slide}{Going generic}
%%   Let us generalise what we learned about wait calls to arbitrary
%%   algebraic effects.  We choose an algebraic theory $(\Sigma, E)$ and
%%   obtain \footnotesize
%
%%   \vspace{0.2cm}
%%    \begin{flalign*}
%%     \infer{\Gamma \vljud x_i : \typeA}{x_i : \typeA \in \Gamma}
%%     \hspace{1cm}
%%     \infer{\Gamma \vljud \ast : \typeOne}{}
%%     \hspace{1cm}
%%     \infer{\Gamma \vljud \langle V, U \rangle : \typeA \times \typeB}
%%     {\Gamma \vljud V : \typeA \qquad  \Gamma \vljud U : \typeB}
%%   \end{flalign*}
%%   \begin{flalign*}
%%        \infer[]{\Gamma \vljud \lambda x : \typeA . \, M : \typeA
%%         \to \typeB}
%%     {\Gamma, x : \typeA \cojud M : \typeB} \hspace{2cm}
%%        \infer[]{\Gamma \vljud \pi_1 V : \typeA}
%%       {\Gamma \vljud V: \typeA \times \typeB}
%%   \end{flalign*}
%%   \dotfill
%%   \begin{flalign*}
%%     \infer{\Gamma \cojud \ret V : \typeA}
%%     {\Gamma \vljud V : \typeA} \hspace{1cm}
%%     \infer{\Gamma \cojud x \leftarrow M \pcomp N : \typeB}
%%     {\Gamma \cojud M : \typeA  \qquad \Gamma, x:\typeA \cojud N : \typeB}
%%   \end{flalign*}
%%   \begin{flalign*}
%%      \infer[]{\Gamma \cojud V \, U : \typeB}
%%       {\Gamma \vljud  V : \typeA \to \typeB \quad
%%        \Gamma \vljud  U : \typeA} \hspace{2cm}
%%      \infer{\Gamma \cojud \sigma(M_1, \dots M_n) : \typeA}{\sigma : n \in \Sigma \qquad
%%      \forall i \leq n . \> \Gamma \cojud M_i : \typeA}
%%   \end{flalign*}
%% \end{slide}
%
%% \begin{slide}{Going generic}
%%   We now need to choose a suitable monad $T$ to interpret the language
%%   \vfill
%  
%%   There are sophisticated ways of doing this
%
%%   \vfill
%%   It is even possible to automatically \dkb{generate} a monad for the language
%
%%   \vfill
%%   Here we will simply choose monads that seem suitable for the
%%   job. By suitable, we mean that for every set $X$ the set $TX$ must
%%   be a $(\Sigma,E)$-algebra.
%% \end{slide}
%
%% \begin{slide}{A generic semantics}
%%     \footnotesize
%%      \begin{flalign*}
%%     \infer{\sem{\Gamma \vljud x_i} = \pi_i}{x_i : \typeA \in \Gamma}
%%     \hspace{1cm}
%%     \infer{\sem{\Gamma \vljud \ast}\ = \> !}{}
%%     \hspace{1cm}
%%     \infer{\sem{\Gamma \vljud \langle V, U \rangle : \typeA \times \typeB} = \pv{f,g}}
%%     {\sem{\Gamma \vljud V : \typeA}\ = f \qquad  \sem{\Gamma \vljud U : \typeB}\ = g}
%%   \end{flalign*}
%%   \begin{flalign*}
%%        \infer[]{\sem{\Gamma \vljud \lambda x : \typeA . \, M : \typeA
%%         \to \typeB} = \lambda f}
%%     {\sem{\Gamma, x : \typeA \cojud M : \typeB}\ = f} \hspace{2cm}
%%        \infer[]{\sem{\Gamma \vljud \pi_1 V : \typeA}\  = \pi_1 \comp f }
%%       {\sem{\Gamma \vljud V: \typeA \times \typeB}}
%%   \end{flalign*}
%%   \dotfill
%%   \begin{flalign*}
%%     \infer{\sem{\Gamma \cojud \ret V : \typeA} = \eta \comp f}
%%     {\sem{\Gamma \vljud V : \typeA} = f} \hspace{1cm}
%%     \infer{\sem{\Gamma \cojud x \leftarrow M \pcomp N : \typeB} = g^\star \comp
%%       \mathrm{str} \comp f}
%%     {\sem{\Gamma \cojud M : \typeA} = f  \qquad \sem{\Gamma, x:\typeA \cojud N : \typeB} = g}
%%   \end{flalign*}
%%   \begin{flalign*}
%%     \infer[]{\sem{\Gamma \cojud V \, U : \typeB} = \mathrm{app} \comp
%%       \pv{f,g}} {\sem{\Gamma \vljud V : \typeA \to \typeB} = f \quad
%%       \sem{\Gamma \vljud U : \typeA} = g} \hspace{0.4cm}
%%     \infer{\sem{\Gamma \cojud \sigma(M_1, \dots M_n)}\ = \sem{\sigma}
%%       \comp \pv{f_1,\dots,f_n}}{\sigma : n \in \Sigma \qquad \forall i
%%       \leq n . \> \sem{\Gamma \cojud M_i : \typeA} = f_i}
%%   \end{flalign*}
%% \end{slide}

\end{document}
